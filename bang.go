package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"strconv"
	"strings"
	"text/template"

	"github.com/pkg/errors"
	"gopkg.in/yaml.v3"
)

func main() {
	verbosePtr := flag.Bool("verbose", false, "debug")
	destPtr := flag.String("dest", "", "destination filename (overrides value from yaml)")
	varsPtr := flag.String("vars", "", "variables (overrides value from yaml)")
	templatePtr := flag.String("template", "", "template filename (overrides value from yaml)")
	flag.Parse()

	if len(flag.Args()) != 1 {
		fmt.Println("need 1 argument: <file.go:line>, got:", flag.Args())
		os.Exit(1)
	}

	bits := strings.SplitN(flag.Args()[0], ":", 2)
	src := bits[0]
	start, err := strconv.Atoi(bits[1])
	if err != nil {
		fmt.Println("invalid line:", err)
		os.Exit(1)
	}

	yamlData, err := cutYaml(src, start)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	if *verbosePtr {
		log.Printf("yamlData:\n%s\n---", string(yamlData))
	}

	var j job
	if len(yamlData) > 0 {
		if err := yaml.Unmarshal(yamlData, &j); err != nil {
			fmt.Println("format fail:", err)
			os.Exit(1)
		}
	}

	if *destPtr != "" {
		j.Dest = *destPtr
	}

	if *varsPtr != "" {
		b, err := os.ReadFile(*varsPtr)
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
		err = yaml.Unmarshal(b, &j.Vars)
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
	}

	if *templatePtr != "" {
		b, err := os.ReadFile(*templatePtr)
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
		j.Template = string(b)
	}

	if err := j.do(); err != nil {
		fmt.Println("job fail:", err)
		os.Exit(1)
	}
}

type job struct {
	Dest     string                 `yaml:"dest"`
	Vars     map[string]interface{} `yaml:"vars"`
	Template string                 `yaml:"template"`
}

func (j job) do() error {
	tpl, err := template.New(j.Dest).Parse(j.Template)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := tpl.Execute(&buf, j.Vars); err != nil {
		return err
	}

	source := append([]byte("// Code generated by github.com/tada-team/bang. DO NOT EDIT.\n\n"), buf.Bytes()...)
	content, err := format.Source(source)
	if err != nil {
		return errors.Wrapf(err, "format fail: %s", string(source))
	}

	if err := os.WriteFile(j.Dest, content, 0644); err != nil {
		return err
	}

	return nil
}

func cutYaml(fname string, start int) ([]byte, error) {
	src, err := os.Open(fname)
	if err != nil {
		return nil, err
	}
	defer func() { _ = src.Close() }()

	var yamlData []byte
	scanner := bufio.NewScanner(src)

	i := 0
	for scanner.Scan() {
		i++
		if i <= start {
			continue
		}

		line := scanner.Text()
		if !strings.HasPrefix(line, "//") {
			break
		}

		if line == "//" {
			line = ""
		} else if strings.HasPrefix(line, "// ") {
			line = strings.TrimPrefix(line, "// ")
		} else if strings.HasPrefix(line, "//\t") {
			line = strings.TrimPrefix(line, "//\t")
		}

		yamlData = append(yamlData, line...)
		yamlData = append(yamlData, "\n"...)
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return yamlData, nil
}
